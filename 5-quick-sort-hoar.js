// быстрая сортировка - самый эффективный алгоритм сортировки и работает он за время O (log2n * n) - суть: мы делим массив на подмассивы и каждый раз рекурсино мы выбираем опорный элемент у каждого массива (чаще всего центральный а не случайный) - пробегаемся по массиву и все элементы котрые меньше по значению чем опорный- добавляем в один массив,  а все которые больше в другой массив - после такой операции у нас получаются два массива с меньшими числами и с большими, чем ОПОРНЫЙ, для каждого из этих массивов выполняется точно такая же операция ..итд - пока длинна массива не станет ровна единице - именно это условие и будет базовым случаем выхода из рекурсии - и после этой операции эти все маленькие подмассивы склеиваются в один большой

// рекурсинвый метод

const arr = [
  0, 3, 2, 5, 6, 8, 1, 9, 4, 2, 1, 2, 9, 6, 4, 1, 7, -1, -5, 23, 6, 2, 35, 6, 3,
  32,
];

let count = 0;

function qiuckSort(array) {
  // базовый случай окончание рекурсии
  if (array.length <= 1) {
    return array;
  }

  // находим центральный опорный элемент
  let pivotIndex = Math.floor(array.length / 2);

  // получам из массива сам опорный элемент
  let pivot = array[pivotIndex];

  // два массива чисел как в описании
  let less = [];
  let greater = [];

  // пробегаемся по массиву и сравниваем кажд элемент с ОПОРНЫМ
  for (let i = 0; i < array.length; i++) {
    count += 1;
    // 3 условия
    if (i === pivotIndex) continue; // сравниваем индекс текущ итерации с индексом опоррн точки -  пропускаем если равны
    if (array[i] < pivot) {
      less.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }

  return [...qiuckSort(less), pivot, ...qiuckSort(greater)];
}

console.log(qiuckSort(arr));
// [
//   -5, -1, 0, 1, 1, 1, 2,  2,
//    2,  2, 3, 3, 4, 4, 5,  6,
//    6,  6, 6, 7, 8, 9, 9, 23,
//   32, 35
// ]

console.log(count); // 112
